@page "/counter"
﻿@using Microsoft.AspNetCore.Components.QuickGrid
@using Oop.Client.Model
@using Oop.Client.Services

<PageTitle>Counter</PageTitle>

@if (isLoaded)
{
    <p>Loading... </p>
}
else
{

    <QuickGrid TGridItem=Person ItemsProvider=@ProvideVirtualizedItems Virtualize="true" class="min-w-full">
        <PropertyColumn Property="@(p => p.EmployeeID)" Sortable="false" />
        <PropertyColumn Property="@(p => p.FirstName)" Sortable="true">
            <ColumnOptions>
                <div class="search-box">
                    <input type="search" autofocus @bind="firstNameFilter" @bind:event="oninput" placeholder="First name..." />
                </div>
            </ColumnOptions>
        </PropertyColumn>
        <PropertyColumn Property="@(p => p.LastName)" Sortable="true" />
        <PropertyColumn Property="@(p => p.AccessLevel)" Sortable="true">
            <ColumnOptions>
                <div class="search-box">
                    <p>Min access level</p>
                    <input type="range" @bind="minAccessLevelFilter" @bind:event="oninput" min="0" max="@maxAccessLevel" />
                    <p>Max access level</p>
                    <input type="range" @bind="maxAccessLevelFilter" @bind:event="oninput" min="0" max="@maxAccessLevel" />
                </div>
            </ColumnOptions>
        </PropertyColumn>

    </QuickGrid>


}
<style>

    .min-w-full {
        min-width: 100%;
    }

    table {
        text-indent: 0;
        border-color: inherit;
        border-collapse: collapse;
    }

    .flow-root {
        display: flow-root;
    }

    .inventory-grid {
        position: relative;
        display: flex;
        flex-grow: 1;
        flex-direction: column;
        justify-content: space-between;
    }

        .inventory-grid::after {
            /* This appears while the user is scrolling before the browser paints the new rows. It's less jarring for the background to be white than dark gray. */
            content: " ";
            background: white;
            position: fixed;
            z-index: -1;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
        }
</style>
@code {
    private bool isLoaded = false;
    private string? firstNameFilter;
    private byte maxAccessLevelFilter = maxAccessLevel;
    private byte minAccessLevelFilter = 0;
    private const byte maxAccessLevel = 255;

    protected override void OnAfterRender(bool firstRender)
    {
        if (firstRender)
        {
            PopulateDataBase();
        }
        base.OnAfterRender(firstRender);
    }

    private IEnumerable<Person> people;
    private void PopulateDataBase()
    {
        FakeService.CreateRandomPeople(500);
        FakeService.OnFakePeopleChanged += (e) =>
        {
            people = e;
            StateHasChanged();
        };
    }


    private async ValueTask<GridItemsProviderResult<Person>> ProvideVirtualizedItems(GridItemsProviderRequest<Person> request)
    {
        if (people is null)
        {
            return GridItemsProviderResult.From<Person>(
                items: Array.Empty<Person>(),
                totalItemCount: 0);
        }
        else
        {
            // Debounce the requests. This eliminates a lot of redundant queries at the cost of slight lag after interactions.
            // If you wanted, you could try to make it only debounce on the 2nd-and-later request within a cluster.
            await Task.Delay(20);
            if (request.CancellationToken.IsCancellationRequested)
            {
                return default;
            }

            var records = FilteredPeople().Skip(request.StartIndex).Take(request.Count ?? 0);

            var sortedRecords = request.ApplySorting(records).ToArray();

            var result = GridItemsProviderResult.From<Person>(
                items: sortedRecords,
                totalItemCount: sortedRecords.Count());
            return result;
        }
    }

    IQueryable<Person> FilteredPeople()
    {
        var result = people.AsQueryable();
        if (!string.IsNullOrEmpty(firstNameFilter))
        {
            result = result.Where(p => p.FirstName.Contains(firstNameFilter, StringComparison.CurrentCultureIgnoreCase));
        }

        result = result.Where(x => x.AccessLevel >= minAccessLevelFilter);
        result = result.Where(x => x.AccessLevel <= maxAccessLevelFilter);

        return result;
    }
}
